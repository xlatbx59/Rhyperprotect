//Author: xlatbx59
//Github profile: https://github.com/xlatbx59
#include <iostream>
#include <fstream>
#include <queue>
#include <string.h>
#include "code_analysis/code_analysis.hpp"
#include "obfuscation/obfuscation.hpp"
#include <unordered_map>

#define ZeroMemory(dst, size) memset(dst, 0, size)

using std::ofstream;

struct SymbolEntry
{
  int64_t pc;
  uint64_t label;
};

inline static uint8_t* assemble_1st_pass( const ZydisMachineMode machine_mode,
                                          vector<SymbolEntry>& symbol_table,
                                          vector<SymbolEntry>& ref_table,
                                          const BasicBlock& bb,
                                          uint64_t& out_size,
                                          int64_t& pc)
{
  uint64_t available_space = bb.size() * 16;
  uint8_t* output = nullptr, *temp = new uint8_t[available_space];
  ZydisEncoderRequest req;
  SymbolEntry symbol_entry;
  SymbolEntry ref_entry;
  ZydisDecodedOperand operand;
  bool flag = false;
  int64_t init_size = pc;
  ZeroMemory(temp, sizeof(available_space));

  for(Instruction inst : bb.insts)
  {
    ZeroMemory(&req, sizeof(ZydisEncoderRequest));
    req.machine_mode = machine_mode;
    req.branch_width = ZYDIS_BRANCH_WIDTH_NONE;

    symbol_entry.pc = pc;
    symbol_entry.label = inst.label;
    symbol_table.push_back(symbol_entry);

    req.mnemonic = inst.get_mnemonic();
    req.operand_count = inst.get_operand_count();
    for(int i = 0; i < req.operand_count; i++)
    {
      inst.get_operand(operand, i);
      switch(operand.type)
      {
        case ZYDIS_OPERAND_TYPE_REGISTER:
          req.operands[i].type = ZYDIS_OPERAND_TYPE_REGISTER;
          req.operands[i].reg.value = operand.reg.value;
          break;
        case ZYDIS_OPERAND_TYPE_MEMORY:
          req.operands[i].type = ZYDIS_OPERAND_TYPE_MEMORY;
          req.operands[i].mem.size = operand.size / 8;
          req.operands[i].mem.base = operand.mem.base;
          req.operands[i].mem.index = operand.mem.index;
          req.operands[i].mem.scale = operand.mem.scale;
          req.operands[i].mem.displacement = operand.mem.disp.value;
          break;
        case ZYDIS_OPERAND_TYPE_IMMEDIATE:
          req.operands[i].type = ZYDIS_OPERAND_TYPE_IMMEDIATE;
          if(inst.has_branch())
          {
            req.branch_width = ZYDIS_BRANCH_WIDTH_32;
            inst.get_branch(ref_entry.label);
            ref_entry.pc = pc;
            ref_table.push_back(ref_entry);
          }
          else
            req.operands[i].imm.u = operand.imm.value.u;
          break;
        default:
          delete [] temp;
          temp = nullptr;
          return nullptr;
      }
    }

    available_space = pc - init_size + bb.size() * 16;
    ZyanStatus status = ZydisEncoderEncodeInstruction(&req, temp + pc - init_size, &available_space);
    if(ZYAN_FAILED(status))
    {
      delete [] temp;
      temp = nullptr;
      return nullptr;
    }

    pc += available_space;
  }

  out_size = pc - init_size;
  output = new uint8_t[pc - init_size];
  ZeroMemory(output, pc - init_size);
  memcpy(output, temp, pc - init_size);
  delete [] temp;
  temp = nullptr;

  return output;
}

uint8_t* assemble(const bool bits, vector<BasicBlock>& bbs, uint64_t& size)
{
  ZydisDecodedInstruction z_inst;
  ZydisDecoder decoder;
  vector<uint64_t> sizes;
  vector<uint8_t*> assembled_bbs;
  vector<SymbolEntry> ref_table;
  vector<SymbolEntry> symbol_table;
  uint64_t bb_size;
  uint64_t encoder_size = 0;
  uint8_t* the_bb, *machine_code = nullptr;
  ZydisEncoderRequest req;
  int64_t pc = 0;
  
  ZeroMemory(&decoder, sizeof(decoder));
	ZydisDecoderInit( &decoder, 
                    bits ? ZYDIS_MACHINE_MODE_LONG_COMPAT_32 : ZYDIS_MACHINE_MODE_LONG_64,
                    bits ? ZYDIS_STACK_WIDTH_32 : ZYDIS_STACK_WIDTH_64);
  
  //1st pass
  for(BasicBlock bb : bbs)
  {
    the_bb = assemble_1st_pass(bits ? ZYDIS_MACHINE_MODE_LONG_COMPAT_32 : ZYDIS_MACHINE_MODE_LONG_64, symbol_table, ref_table, bb, bb_size, pc);
    if(!the_bb)
    {
      for(uint8_t* machine_code : assembled_bbs)
        delete [] machine_code;
      return nullptr;
    }
    sizes.push_back(bb_size);
    assembled_bbs.push_back(the_bb);
  }

  machine_code = new uint8_t[pc];
  ZeroMemory(machine_code, pc);
  pc = 0;

  for(int i = 0; i < assembled_bbs.size(); i++)
  {
    memcpy(machine_code + pc, assembled_bbs[i], sizes[i]);
    delete [] assembled_bbs[i];
    pc += sizes[i];
  }

  sizes.clear();
  assembled_bbs.clear();

  //2nd pass
  ZydisDecodedOperand operands[10];
  
  ZeroMemory(&req, sizeof(ZydisEncoderRequest));
  req.machine_mode = bits ? ZYDIS_MACHINE_MODE_LONG_COMPAT_32 : ZYDIS_MACHINE_MODE_LONG_64;
  req.operands[0].type = ZYDIS_OPERAND_TYPE_IMMEDIATE;
  req.branch_width = ZYDIS_BRANCH_WIDTH_32;

  for(SymbolEntry ref : ref_table)
  {
    for(SymbolEntry target : symbol_table)
    {
      if(target.label != ref.label)
        continue;

      if(ZYAN_FAILED(ZydisDecoderDecodeFull(
                /* decoder:         */ &decoder,
                /* buffer:          */ machine_code + ref.pc,
                /* length:          */ pc - ref.pc,
                /* instruction:     */ &z_inst,
                /* operand:     	  */ operands
      )))
        return nullptr;

      if (z_inst.operand_count_visible != 1 || operands[0].type != ZYDIS_OPERAND_TYPE_IMMEDIATE)
        return nullptr;

      encoder_size = z_inst.length;
      req.mnemonic = z_inst.mnemonic;
      req.operand_count = z_inst.operand_count_visible;
      req.operands[0].imm.u = target.pc - (ref.pc + z_inst.length);

      ZyanStatus status = ZydisEncoderEncodeInstruction(&req, machine_code + ref.pc, &encoder_size);
      if(ZYAN_FAILED(status))
        return nullptr;
    }
  }

  size = (uint64_t)pc;
  return machine_code;
}

void bubble_sort_vector(vector<BasicBlock>& bbs)
{
  bool flag = false;
  do
  {
    flag = false;
    for(int i = 0; i < bbs.size() - 1; i++)
    {
      if(bbs[i].bb_addr > bbs[i + 1].bb_addr)
      {
        std::swap(bbs[i], bbs[i + 1]);
        flag = true;
      }
    }
  }while (flag);
}

int main(void)
{
  vector<ZyanU64> disassembled;
	const uint8_t code[] = {
    0x55, 0x48, 0x89, 0xe5, 0x48, 0x81, 0xec, 0x40, 0x01, 0x00, 0x00, 0x48, 0x89, 0xbd, 0xd8,
    0xfe, 0xff, 0xff, 0x89, 0xb5, 0xd4, 0xfe, 0xff, 0xff, 0x48, 0x89, 0x95, 0xc8, 0xfe, 0xff,
    0xff, 0x89, 0x8d, 0xd0, 0xfe, 0xff, 0xff, 0x4c, 0x89, 0x85, 0xc0, 0xfe, 0xff, 0xff, 0x64,
    0x48, 0x8b, 0x04, 0x25, 0x28, 0x00, 0x00, 0x00, 0x48, 0x89, 0x45, 0xf8, 0x31, 0xc0, 0xc7,
    0x85, 0xe4, 0xfe, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x85, 0xe8, 0xfe, 0xff, 0xff,
    0x00, 0x00, 0x00, 0x00, 0x48, 0x83, 0xbd, 0xd8, 0xfe, 0xff, 0xff, 0x00, 0x74, 0x32, 0x48,
    0x83, 0xbd, 0xc8, 0xfe, 0xff, 0xff, 0x00, 0x74, 0x28, 0x83, 0xbd, 0xd0, 0xfe, 0xff, 0xff,
    0x00, 0x74, 0x1f, 0x83, 0xbd, 0xd4, 0xfe, 0xff, 0xff, 0x00, 0x74, 0x16, 0x48, 0x83, 0xbd,
    0xc0, 0xfe, 0xff, 0xff, 0x00, 0x74, 0x0c, 0x81, 0xbd, 0xd0, 0xfe, 0xff, 0xff, 0x00, 0x01,
    0x00, 0x00, 0x76, 0x0a, 0xb8, 0x00, 0x00, 0x00, 0x00, 0xe9, 0x00, 0x02, 0x00, 0x00, 0xc7,
    0x85, 0xe8, 0xfe, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xeb, 0x1e, 0x8b, 0x85, 0xe8, 0xfe,
    0xff, 0xff, 0x89, 0xc2, 0x8b, 0x85, 0xe8, 0xfe, 0xff, 0xff, 0x48, 0x98, 0x88, 0x94, 0x05,
    0xf0, 0xfe, 0xff, 0xff, 0x83, 0x85, 0xe8, 0xfe, 0xff, 0xff, 0x01, 0x81, 0xbd, 0xe8, 0xfe,
    0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x7e, 0xd6, 0xc7, 0x85, 0xe8, 0xfe, 0xff, 0xff, 0x00,
    0x00, 0x00, 0x00, 0xe9, 0x8f, 0x00, 0x00, 0x00, 0x8b, 0x85, 0xe8, 0xfe, 0xff, 0xff, 0x48,
    0x98, 0x0f, 0xb6, 0x84, 0x05, 0xf0, 0xfe, 0xff, 0xff, 0x0f, 0xb6, 0xd0, 0x8b, 0x85, 0xe4,
    0xfe, 0xff, 0xff, 0x8d, 0x0c, 0x02, 0x8b, 0x85, 0xe8, 0xfe, 0xff, 0xff, 0xba, 0x00, 0x00,
    0x00, 0x00, 0xf7, 0xb5, 0xd0, 0xfe, 0xff, 0xff, 0x89, 0xd0, 0x89, 0xc2, 0x48, 0x8b, 0x85,
    0xc8, 0xfe, 0xff, 0xff, 0x48, 0x01, 0xd0, 0x0f, 0xb6, 0x00, 0x0f, 0xb6, 0xc0, 0x8d, 0x14,
    0x01, 0x89, 0xd0, 0xc1, 0xf8, 0x1f, 0xc1, 0xe8, 0x18, 0x01, 0xc2, 0x0f, 0xb6, 0xd2, 0x29,
    0xc2, 0x89, 0x95, 0xe4, 0xfe, 0xff, 0xff, 0x48, 0x8d, 0x95, 0xf0, 0xfe, 0xff, 0xff, 0x8b,
    0x85, 0xe4, 0xfe, 0xff, 0xff, 0x48, 0x98, 0x48, 0x01, 0xc2, 0x48, 0x8d, 0x8d, 0xf0, 0xfe,
    0xff, 0xff, 0x8b, 0x85, 0xe8, 0xfe, 0xff, 0xff, 0x48, 0x98, 0x48, 0x01, 0xc8, 0x48, 0x89,
    0xd6, 0x48, 0x89, 0xc7, 0xe8, 0xb9, 0x01, 0x00, 0x00, 0x83, 0x85, 0xe8, 0xfe, 0xff, 0xff,
    0x01, 0x81, 0xbd, 0xe8, 0xfe, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x0f, 0x8e, 0x61, 0xff,
    0xff, 0xff, 0xc7, 0x85, 0xe8, 0xfe, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x85, 0xe4,
    0xfe, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x85, 0xec, 0xfe, 0xff, 0xff, 0x00, 0x00,
    0x00, 0x00, 0xe9, 0xe2, 0x00, 0x00, 0x00, 0x8b, 0x85, 0xe8, 0xfe, 0xff, 0xff, 0x8d, 0x50,
    0x01, 0x89, 0xd0, 0xc1, 0xf8, 0x1f, 0xc1, 0xe8, 0x18, 0x01, 0xc2, 0x0f, 0xb6, 0xd2, 0x29,
    0xc2, 0x89, 0x95, 0xe8, 0xfe, 0xff, 0xff, 0x8b, 0x85, 0xe8, 0xfe, 0xff, 0xff, 0x48, 0x98,
    0x0f, 0xb6, 0x84, 0x05, 0xf0, 0xfe, 0xff, 0xff, 0x0f, 0xb6, 0xd0, 0x8b, 0x85, 0xe4, 0xfe,
    0xff, 0xff, 0x01, 0xc2, 0x89, 0xd0, 0xc1, 0xf8, 0x1f, 0xc1, 0xe8, 0x18, 0x01, 0xc2, 0x0f,
    0xb6, 0xd2, 0x29, 0xc2, 0x89, 0x95, 0xe4, 0xfe, 0xff, 0xff, 0x48, 0x8d, 0x95, 0xf0, 0xfe,
    0xff, 0xff, 0x8b, 0x85, 0xe4, 0xfe, 0xff, 0xff, 0x48, 0x98, 0x48, 0x01, 0xc2, 0x48, 0x8d,
    0x8d, 0xf0, 0xfe, 0xff, 0xff, 0x8b, 0x85, 0xe8, 0xfe, 0xff, 0xff, 0x48, 0x98, 0x48, 0x01,
    0xc8, 0x48, 0x89, 0xd6, 0x48, 0x89, 0xc7, 0xe8, 0x02, 0x01, 0x00, 0x00, 0x8b, 0x85, 0xec,
    0xfe, 0xff, 0xff, 0x48, 0x63, 0xd0, 0x48, 0x8b, 0x85, 0xd8, 0xfe, 0xff, 0xff, 0x48, 0x01,
    0xd0, 0x0f, 0xb6, 0x30, 0x8b, 0x85, 0xe8, 0xfe, 0xff, 0xff, 0x48, 0x98, 0x0f, 0xb6, 0x94,
    0x05, 0xf0, 0xfe, 0xff, 0xff, 0x8b, 0x85, 0xe4, 0xfe, 0xff, 0xff, 0x48, 0x98, 0x0f, 0xb6,
    0x84, 0x05, 0xf0, 0xfe, 0xff, 0xff, 0x01, 0xd0, 0x0f, 0xb6, 0xc0, 0x48, 0x98, 0x0f, 0xb6,
    0x8c, 0x05, 0xf0, 0xfe, 0xff, 0xff, 0x8b, 0x85, 0xec, 0xfe, 0xff, 0xff, 0x48, 0x63, 0xd0,
    0x48, 0x8b, 0x85, 0xc0, 0xfe, 0xff, 0xff, 0x48, 0x01, 0xd0, 0x31, 0xce, 0x89, 0xf2, 0x88,
    0x10, 0x83, 0x85, 0xec, 0xfe, 0xff, 0xff, 0x01, 0x8b, 0x85, 0xec, 0xfe, 0xff, 0xff, 0x3b,
    0x85, 0xd4, 0xfe, 0xff, 0xff, 0x0f, 0x82, 0x0c, 0xff, 0xff, 0xff, 0xb8, 0x01, 0x00, 0x00,
    0x00, 0x48, 0x8b, 0x55, 0xf8, 0x64, 0x48, 0x2b, 0x14, 0x25, 0x28, 0x00, 0x00, 0x00, 0x74,
    0x05, 0x66, 0x48, 0x90, 0x90, 0x90, 0xc9, 0xc3, 0x55, 0x48, 0x89, 0xe5, 0x48, 0x83, 0xec,
    0x20, 0x64, 0x48, 0x8b, 0x04, 0x25, 0x28, 0x00, 0x00, 0x00, 0x48, 0x89, 0x45, 0xf8, 0x31,
    0xc0, 0xc7, 0x45, 0xee, 0x70, 0x65, 0x64, 0x69, 0xc6, 0x45, 0xf2, 0x61, 0xc7, 0x45, 0xf3,
    0x00, 0x00, 0x00, 0x00, 0xc6, 0x45, 0xf7, 0x00, 0xc7, 0x45, 0xea, 0x57, 0x69, 0x6b, 0x69,
    0x48, 0x8d, 0x4d, 0xf3, 0x48, 0x8d, 0x55, 0xea, 0x48, 0x8d, 0x45, 0xee, 0x49, 0x89, 0xc8,
    0xb9, 0x04, 0x00, 0x00, 0x00, 0xbe, 0x05, 0x00, 0x00, 0x00, 0x48, 0x89, 0xc7, 0xe8, 0x00,
    0xfd, 0xff, 0xff, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x48, 0x8b, 0x55, 0xf8, 0x64, 0x48, 0x2b,
    0x14, 0x25, 0x28, 0x00, 0x00, 0x00, 0x74, 0x05, 0x66, 0x48, 0x90, 0x90, 0x90, 0xc9, 0xc3,
    0x55, 0x48, 0x89, 0xe5, 0x48, 0x89, 0x7d, 0xe8, 0x48, 0x89, 0x75, 0xe0, 0x48, 0x8b, 0x45,
    0xe8, 0x0f, 0xb6, 0x00, 0x88, 0x45, 0xff, 0x48, 0x8b, 0x45, 0xe0, 0x0f, 0xb6, 0x10, 0x48,
    0x8b, 0x45, 0xe8, 0x88, 0x10, 0x48, 0x8b, 0x45, 0xe0, 0x0f, 0xb6, 0x55, 0xff, 0x88, 0x10,
    0x90, 0x5d, 0xc3
  };

	ZydisDecoder decoder;
	vector<BasicBlock>program;
	uint8_t* machine_code = nullptr;
	uint64_t size = 0, temp = 0;

	disassemble(decoder, program, disassembled, code, sizeof(code), 0, false, 0x00101139);
  bubble_sort_vector(program);
  shuffle_bbs(program);
  for(int i = 0; i < program.size(); i++)
    mutate_ret_no_op(program[i]);
  for(int i = 0; i < program.size(); i++)
    mutate_mov(program[i]);
  machine_code = assemble(false, program, size);

  ofstream myfile;
  myfile.open ("thefile_patched.bin");
  myfile.write((const char*)machine_code, size);
  myfile.close();

  return 0;
}
